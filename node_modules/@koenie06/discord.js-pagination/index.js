const { MessageButton, MessageActionRow, MessageSelectMenu } = require('discord.js');
exports.button = async (options = {}) => {

    // Checks

    let { message, pages, buttons, timeout } = options;
    if (!message || !message?.author) throw new Error(`INVALID_MESSAGE: There is no valid Message provided.`);
    if (!pages || !(pages instanceof Array) || pages?.length <= 1) throw new Error(`INVALID_PAGES: There is no valid pages Array provided, or the Array's length is 0 / 1.`);
    if (!timeout || !Number.isInteger(timeout)) timeout = 60000;

    // Buttons

    const previousButton = new MessageButton()
        .setCustomId('previous')
        .setLabel(buttons?.previous?.label ? buttons?.previous?.label : 'Previous')
        .setStyle(buttons?.previous?.style ? buttons?.previous?.style : 'PRIMARY')
        buttons?.previous?.emoji && buttons?.previous?.emoji === false ? false : previousButton.setEmoji(buttons?.previous?.emoji ? buttons?.previous?.emoji : '◀');

    const nextButton = new MessageButton()
        .setCustomId('next')
        .setLabel(buttons?.next?.label ? buttons?.next?.label : 'Next')
        .setStyle(buttons?.next?.style ? buttons?.next?.style : 'PRIMARY')
        buttons?.previous?.emoji && buttons?.previous?.emoji === false ? false : nextButton.setEmoji(buttons?.next?.emoji ? buttons?.next?.emoji : '▶');

    const stopButton = new MessageButton()
        .setCustomId('stop')
        .setLabel(buttons?.stop?.label ? buttons?.stop?.label : 'Stop')
        .setStyle(buttons?.stop?.style ? buttons?.stop?.style : 'DANGER')
        buttons?.previous?.emoji && buttons?.previous?.emoji === false ? false : stopButton.setEmoji(buttons?.stop?.emoji ? buttons?.stop?.emoji : '⛔');

    const row = new MessageActionRow()
        .addComponents(previousButton, nextButton, stopButton);

    // Starting the paginator

    await pages[0].setFooter(`Page 1/${pages.length}`);
    const msg = await message.channel.send({ embeds: [pages[0]], components: [row] });

    const filter = m => m;
    const collector = msg.createMessageComponentCollector({ filter, time: timeout });

    // Changing page when button clicked

    let currentPage = 0;
    let stopped = false;

    collector.on('collect', async component => {

        component.deferUpdate();
        if (component.user.id !== message.author.id) return;

        if (component.customId === 'previous') {

            if (currentPage === 0) currentPage = pages.length - 1;
            else await currentPage--;

            await pages[currentPage].setFooter(`Page ${currentPage + 1}/${pages.length}`);
            msg.edit({ embeds: [pages[currentPage]], components: [row] });

        } else if (component.customId === 'next') {

            if (currentPage === pages.length - 1) currentPage = 0;
            else await currentPage++;

            await pages[currentPage].setFooter(`Page ${currentPage + 1}/${pages.length}`);
            await msg.edit({ embeds: [pages[currentPage]], components: [row] });

        } else {

            collector.stop();
            stopped = true;

            await previousButton.setDisabled();
            await nextButton.setDisabled();
            await stopButton.setDisabled();

            await pages[currentPage].setFooter(`Page ${currentPage + 1}/${pages.length}`);
            await msg.edit({ embeds: [pages[currentPage]], components: [row] });

        };

    });

    // When the time is up, disable the buttons

    collector.on('end', async () => {

        if (stopped === true) return;

        await previousButton.setDisabled();
        await nextButton.setDisabled();
        await stopButton.setDisabled();

        await pages[currentPage].setFooter(`Page ${currentPage + 1}/${pages.length}`);
        await msg.edit({ embeds: [pages[currentPage]], components: [row] });

    });
};

exports.emoji = async (options = {}) => {

    // Checks

    let { message, pages, emojis, timeout } = options;
    if (!message || !message?.author) throw new Error(`INVALID_MESSAGE: There is no valid Message provided.`);
    if (!pages || !(pages instanceof Array) || pages?.length <= 1) throw new Error(`INVALID_PAGES: There is no valid pages Array provided, or the Array's length is 0 / 1.`);
    if (!timeout || !Number.isInteger(timeout)) timeout = 60000;

    // Starting the paginator

    await pages[0].setFooter(`Page 1/${pages.length}`);
    const msg = await message.channel.send({ embeds: [pages[0]] });

    await msg.react(emojis?.previous ? emojis?.previous : '◀');
    await msg.react(emojis?.next ? emojis?.next : '▶');
    await msg.react(emojis?.stop ? emojis?.stop : '⛔');

    const filter = reaction => [emojis?.previous ? emojis?.previous : '◀', emojis?.next ? emojis?.next : '▶', emojis?.stop ? emojis?.stop : '⛔'].includes(reaction.emoji.name)
    const collector = msg.createReactionCollector({ filter, time: timeout });

    // Changing page when reaction clicked

    let currentPage = 0;

    collector.on('collect', async (reaction, user) => {

        await reaction.message.resolve(reaction.emoji.id).users.remove(user.id);
        if (user.id !== message.author.id) return;

        if (reaction.emoji.name === emojis?.previous ? emojis?.previous : '◀') {

            if (currentPage === 0) currentPage = pages.length - 1;
            else await currentPage--;

            await pages[currentPage].setFooter(`Page ${currentPage + 1}/${pages.length}`);
            msg.edit({ embeds: [pages[currentPage]] });

        } else if (reaction.emoji.name === emojis?.next ? emojis?.next : '▶') {

            if (currentPage === pages.length - 1) currentPage = 0;
            else await currentPage++;

            await pages[currentPage].setFooter(`Page ${currentPage + 1}/${pages.length}`);
            await msg.edit({ embeds: [pages[currentPage]] });

        } else {

            collector.stop();

            await pages[currentPage].setFooter(`Page ${currentPage + 1}/${pages.length}`);
            await msg.edit({ embeds: [pages[currentPage]] });

        };

    });
};

exports.menu = async (options = {}) => {

    let { message, menus, timeout } = options;
    let { pages, placeHolder } = menus

    if (!message || !message?.author) throw new Error(`INVALID_MESSAGE: There is no valid Message provided.`);
    if (!pages || !(pages instanceof Array) || pages?.length <= 1) throw new Error(`INVALID_PAGES: There is no valid pages Array provided, or the Array's length is 0 / 1.`);
    if (!timeout || !Number.isInteger(timeout)) timeout = 60000;

    const Menu = new MessageSelectMenu()
        .setCustomId("sel_menu_pages")
        .setPlaceholder((placeHolder) ? placeHolder : "Select something!")
        .addOptions(pages);

    const msg = await message.channel.send({ embeds: [pages[0].embed], components: [new MessageActionRow().addComponents(Menu)] });

    const filter = m => m;
    // @ts-ignore
    const collector = await msg.createMessageComponentCollector({ filter, time: timeout });

    collector.on("collect", async (component) => {

        for await (const value of component.values) {
            for (const page of pages) {
                if (page.value === value) {
                    await component.deferUpdate()
                    await msg.edit({ embeds: [page.embed] });
                    return;
                } else {
                    continue;
                };
            };
        };
    });

    collector.once("end", async () => {

        const disabledActionrow = new MessageActionRow().addComponents(Menu.setDisabled(true));
        await msg.edit({ embeds: [pages[0].embed], components: [disabledActionrow] });

    });

};
